<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Custom Memory Allocator | WageCo&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/css/highlight.css">

  
  <meta name="description" content="如何实现一个简单内存分配具体代码可以参考我这里实现的简单动态内存分配这里仅仅只是实现了的内存的分配，之后还需要实现内存池，并且通过栈的方式进行管理才能方便使用。">
<meta property="og:type" content="article">
<meta property="og:title" content="Custom Memory Allocator">
<meta property="og:url" content="https://wageco.github.io/2022/04/11/2022-4-11-MemoryAllocator/index.html">
<meta property="og:site_name" content="WageCo&#39;s Blog">
<meta property="og:description" content="如何实现一个简单内存分配具体代码可以参考我这里实现的简单动态内存分配这里仅仅只是实现了的内存的分配，之后还需要实现内存池，并且通过栈的方式进行管理才能方便使用。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wageco.github.io/.io//MemoryLayout.png">
<meta property="og:image" content="https://wageco.github.io/.io//MemoryMalloc.png">
<meta property="article:published_time" content="2022-04-10T16:09:47.000Z">
<meta property="article:modified_time" content="2024-11-03T16:57:02.718Z">
<meta property="article:author" content="WageCo">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wageco.github.io/.io//MemoryLayout.png"><meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="wrapper">
    <header id="header">
  <h1 id="title">
    <a href="/">WageCo&#39;s Blog</a>
  </h1>
  <nav>
    
    
      
      <a class="nav-link" href="/">Home</a>
    
      
        <span class="nav-spacer">×</span>
      
      <a class="nav-link" href="/archives">Archives</a>
    
    
  </nav>
</header>

    <div id="content">
      <article id="post-2022-4-11-MemoryAllocator" class="article article-type-post" itemprop="blogPost" itemscope>
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 class="article-title" itemprop="headline name">
      Custom Memory Allocator
    </h2>
  


        <div class="article-meta">
          <time class="article-date" datetime="2022-04-10T16:09:47.000Z" itemprop="datePublished">四月 11, 2022, 12:09 凌晨</time>

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      
        <h1 id="如何实现一个简单内存分配"><a href="#如何实现一个简单内存分配" class="headerlink" title="如何实现一个简单内存分配"></a>如何实现一个简单内存分配</h1><p>具体代码可以参考我这里实现的<a target="_blank" rel="noopener" href="https://github.com/WageCo/mmemory">简单动态内存分配</a><br>这里仅仅只是实现了的内存的分配，之后还需要实现内存池，并且通过栈的方式进行管理才能方便使用。</p>
<span id="more"></span>

<p>在实现这个问题之前，我们需要了解一下程序中的内存布局。</p>
<ul>
<li>text<br>存放要由处理器执行的二进制指令的部分。</li>
<li>data、<br>存放非零初始化的静态数据</li>
<li>bss<br>存放初始化为零的静态数据，并且未初始化的静态数据被初始化为零后将合并到这个区域</li>
<li>heap<br>这里主要是动态分配的数据，也叫堆</li>
<li>stack<br>这里是局部变量等非动态分配的数据，也叫栈</li>
</ul>
<p><img src="/.io//MemoryLayout.png" alt="MemoryLayout"></p>
<blockquote>
<p>可以看到堆和栈的增长方式是<strong>相对生长</strong>  </p>
</blockquote>
<blockquote>
<p>开始有个一个指针叫做<strong>program break</strong>或者<strong>brk</strong>,他是与bss重合的,当开始分配的内存，brk会上升，其中增大的内存空间为heap。</p>
</blockquote>
<blockquote>
<p>所以当我们需要动态分配空间的时候，需要请求系统，系统内部接口会帮助我们增大brk指针</p>
</blockquote>
<blockquote>
<p>相反，当我们需要释放空间的时候，也需要请求系统，系统内部接口会帮助我们减小brk指针</p>
</blockquote>
<h2 id="如何操控brk指针"><a href="#如何操控brk指针" class="headerlink" title="如何操控brk指针"></a>如何操控brk指针</h2><blockquote>
<p>本文使用的是<strong>linux操作系统</strong>。系统接口函数为 <strong>sbrk()</strong><br>当然也可以使用 <strong>brk()</strong> 这个系统调用。</p>
</blockquote>
<blockquote>
<p>具体使用方法可以通过命令 <strong>man sbrk</strong> 来查看。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sbrk</span>(<span class="number">0</span>); <span class="comment">// 获取当前brk指针</span></span><br><span class="line"><span class="built_in">sbrk</span>(n); <span class="comment">// 分配大小为n个字节的内存空间, brk指针增大n个字节, 返回分配的起始地址</span></span><br><span class="line"><span class="built_in">sbrk</span>(-n); <span class="comment">// 释放大小为n个字节的内存空间, brk指针减小n个字节, 返回分配的起始地址</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>申请或者释放total_size个字节空间</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *now_addr = <span class="built_in">sbrk</span>(total_size);</span><br><span class="line"><span class="keyword">if</span> (now_addr == (<span class="type">void</span> *)<span class="number">-1</span>) &#123; </span><br><span class="line">  <span class="comment">// failed</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s errno: %s\n&quot;</span>, __func__, <span class="built_in">strerror</span>(errno));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于每次分配内存返回的是其实地址, 考虑到释放问题, 我们每次分配都需要添加一个头结构体, 用来保存一下用户需要分配的内存大小, 以及进行填充来实现内存对齐。</p>
</blockquote>
<h2 id="添加头部分"><a href="#添加头部分" class="headerlink" title="添加头部分"></a>添加头部分</h2><blockquote>
<p>我这里实现的是对齐16个字节</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 16 位对齐</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> align_to = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ALIGN[align_to];</span><br><span class="line"><span class="comment">// 标头</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">header</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">header</span> *pre;</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">header</span> *next;</span><br><span class="line">  &#125; head;</span><br><span class="line">  ALIGN align;</span><br><span class="line">&#125; <span class="type">header_t</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实这里可以化简, 不需要指向下一个以及上一个被分配的空间的指针</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 16 位对齐</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> align_to = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ALIGN[align_to];</span><br><span class="line"><span class="comment">// 标头</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">header</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">  &#125; head;</span><br><span class="line">  ALIGN align;</span><br><span class="line">&#125; <span class="type">header_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/.io//MemoryMalloc.png" alt="MemoryMalloc"></p>
<h2 id="关于内存对齐问题"><a href="#关于内存对齐问题" class="headerlink" title="关于内存对齐问题"></a>关于内存对齐问题</h2><p>我们调用sbrk分配空间的时候, 为了提高Cpu读取的效率, 我们需要进行内存对齐</p>
<p>例如 我们的Cpu每次读取16个字节<br>如果 分配的内存是16的n倍, 那么只需要读取n次即可<br>但是如果不是, 那么就会读取超过n次</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">假设XXXX为其他数据, OOOO为我们分配的数据</span><br><span class="line">分配同样大小的空间</span><br><span class="line"></span><br><span class="line">Cpu 读取  -&gt; XXXX XXXX XXXX XXXX </span><br><span class="line">Cpu 读取  -&gt; OOOO OOOO OOOO OOOO</span><br><span class="line">Cpu 读取  -&gt; XXXX XXXX XXXX XXXX</span><br><span class="line">如上排列, Cpu只需要读1次, 就可以获取我们分配的空间</span><br><span class="line"></span><br><span class="line">Cpu 读取  -&gt; XXXX XXXX XXXX OOOO  </span><br><span class="line">Cpu 读取  -&gt; OOOO OOOO OOOO XXXX</span><br><span class="line">Cpu 读取  -&gt; XXXX XXXX XXXX XXXX</span><br><span class="line">这样排列, Cpu就需要读2次</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这就是内存对齐的好处</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果要分配size个字节, 那么实际要分配total_size个字节</span></span><br><span class="line"><span class="type">size_t</span> total_size = (<span class="built_in">sizeof</span>(<span class="type">header_t</span>) + size + align_to - <span class="number">1</span>) &amp; ~(align_to - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>其实就是使得每次分配的内存空间(包含头以及填充), 使得为16的整数倍</p>
<h2 id="malloc核心代码"><a href="#malloc核心代码" class="headerlink" title="malloc核心代码"></a>malloc核心代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// malloc memory space</span></span><br><span class="line"><span class="type">void</span> *now_addr = <span class="built_in">sbrk</span>(total_size);</span><br><span class="line">  <span class="comment">// failed</span></span><br><span class="line"><span class="keyword">if</span> (now_addr == (<span class="type">void</span> *)<span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s errno: %s\n&quot;</span>, __func__, <span class="built_in">strerror</span>(errno));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="free核心代码"><a href="#free核心代码" class="headerlink" title="free核心代码"></a>free核心代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free memory space</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">sbrk</span>(<span class="number">0</span> - (<span class="built_in">sizeof</span>(<span class="type">header_t</span>) + node-&gt;head.size)) == (<span class="type">void</span> *)<span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s errno: %s\n&quot;</span>, __func__, <span class="built_in">strerror</span>(ENOMEM));</span><br><span class="line">  <span class="built_in">pthrad_mutex_unlock</span>(&amp;list_locker);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    <div class="article-category">
      
        <b>Categories:</b>
        <a class="article-category-link" href="/categories/C-%E7%9B%B8%E5%85%B3/">C++相关</a>
      
      
        <br/>
      
      
        <b>Tags:</b>
        <a class="article-tag-none-link" href="/tags/C/" rel="tag">C++</a>
      
    </div>
    
    
  </div>
</article>

  
<nav id="article-nav" class="article-nav">
  
    <span id="article-nav-newer" class="article-nav-link-wrap newer"></span>
  
  
    <a href="/2022/01/26/GCCLinkNewGlibc/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          调用Cmake连接指定的GLIBC
        
      </div>
    </a>
  
</nav>






    </div>
  </div>
  




<div id="settings-container">
  <div id="dark-mode">dark</div>
  <div id="sans-font">sans</div>
</div>
<script type="text/javascript">
let d=document,r=d.documentElement.style,f=r.setProperty.bind(r),l=localStorage,s=l.getItem('s')||(window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches),n=l.getItem('n'),m=d.getElementById("dark-mode"),b=()=>{f('--bg-color','#fafafa');f('--code-bg-color','#f4f4f4');f('--text-color','#212121');f('--secondary-color','#808080');f('--tertiary-color','#b0b0b0');f('--link-color','#b5c8cf');f('--link-hover-color','#618794');f('--link-bg-color','#dae4e7');f('--selection-color','#dae4e7');m.innerHTML="dark"},c=()=>{f('--bg-color','#212121');f('--code-bg-color','#292929');f('--text-color','#fff');f('--secondary-color','#c0c0c0');f('--tertiary-color','#6e6e6e');f('--link-color','#4d6b75');f('--link-hover-color','#96b1bb');f('--link-bg-color','#5d828e');f('--selection-color','#acc1c9');m.innerHTML="light"},o=d.getElementById("sans-font"),e=()=>{f('--body-stack','"Lora", "Georgia", "Times New Roman", serif');o.innerHTML="sans"},g=()=>{f('--body-stack','"Lato", "Lucida Grande", "Lucida Sans Unicode", "Lucida Sans", "Verdana", sans-serif');o.innerHTML="serif"};m.onclick=()=>{if(s==2){s=1;l.setItem('s',s);c()}else{s=2;l.setItem('s',s);b()}};o.onclick=()=>{if(n==2){n=1;l.setItem('n',n);g()}else{n=2;l.setItem('n',n);e()}};if(!s){s=2;l.setItem('s',2)};if(s==1){c()};if(!n){n=2;l.setItem('n',2)};if(n==1){g()};
</script>




</body>
</html>
