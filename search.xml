<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Custom Memory Allocator</title>
      <link href="/2022/04/11/2022-4-11-MemoryAllocator/"/>
      <url>/2022/04/11/2022-4-11-MemoryAllocator/</url>
      
        <content type="html"><![CDATA[<h1 id="如何实现一个简单内存分配"><a href="#如何实现一个简单内存分配" class="headerlink" title="如何实现一个简单内存分配"></a>如何实现一个简单内存分配</h1><p>具体代码可以参考我这里实现的<a href="https://github.com/WageCo/mmemory">简单动态内存分配</a><br>这里仅仅只是实现了的内存的分配，之后还需要实现内存池，并且通过栈的方式进行管理才能方便使用。</p><span id="more"></span><p>在实现这个问题之前，我们需要了解一下程序中的内存布局。</p><ul><li>text<br>存放要由处理器执行的二进制指令的部分。</li><li>data、<br>存放非零初始化的静态数据</li><li>bss<br>存放初始化为零的静态数据，并且未初始化的静态数据被初始化为零后将合并到这个区域</li><li>heap<br>这里主要是动态分配的数据，也叫堆</li><li>stack<br>这里是局部变量等非动态分配的数据，也叫栈</li></ul><p><img src="/.io//2022-4-11-MemoryAllocator/MemoryLayout.png" alt="MemoryLayout"></p><blockquote><p>可以看到堆和栈的增长方式是<strong>相对生长</strong>  </p></blockquote><blockquote><p>开始有个一个指针叫做<strong>program break</strong>或者<strong>brk</strong>,他是与bss重合的,当开始分配的内存，brk会上升，其中增大的内存空间为heap。</p></blockquote><blockquote><p>所以当我们需要动态分配空间的时候，需要请求系统，系统内部接口会帮助我们增大brk指针</p></blockquote><blockquote><p>相反，当我们需要释放空间的时候，也需要请求系统，系统内部接口会帮助我们减小brk指针</p></blockquote><h2 id="如何操控brk指针"><a href="#如何操控brk指针" class="headerlink" title="如何操控brk指针"></a>如何操控brk指针</h2><blockquote><p>本文使用的是<strong>linux操作系统</strong>。系统接口函数为 <strong>sbrk()</strong><br>当然也可以使用 <strong>brk()</strong> 这个系统调用。</p></blockquote><blockquote><p>具体使用方法可以通过命令 <strong>man sbrk</strong> 来查看。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sbrk</span>(<span class="number">0</span>); <span class="comment">// 获取当前brk指针</span></span><br><span class="line"><span class="built_in">sbrk</span>(n); <span class="comment">// 分配大小为n个字节的内存空间, brk指针增大n个字节, 返回分配的起始地址</span></span><br><span class="line"><span class="built_in">sbrk</span>(-n); <span class="comment">// 释放大小为n个字节的内存空间, brk指针减小n个字节, 返回分配的起始地址</span></span><br></pre></td></tr></table></figure><blockquote><p>申请或者释放total_size个字节空间</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *now_addr = <span class="built_in">sbrk</span>(total_size);</span><br><span class="line"><span class="keyword">if</span> (now_addr == (<span class="type">void</span> *)<span class="number">-1</span>) &#123; </span><br><span class="line">  <span class="comment">// failed</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s errno: %s\n&quot;</span>, __func__, <span class="built_in">strerror</span>(errno));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于每次分配内存返回的是其实地址, 考虑到释放问题, 我们每次分配都需要添加一个头结构体, 用来保存一下用户需要分配的内存大小, 以及进行填充来实现内存对齐。</p></blockquote><h2 id="添加头部分"><a href="#添加头部分" class="headerlink" title="添加头部分"></a>添加头部分</h2><blockquote><p>我这里实现的是对齐16个字节</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 16 位对齐</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> align_to = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ALIGN[align_to];</span><br><span class="line"><span class="comment">// 标头</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">header</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">header</span> *pre;</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">header</span> *next;</span><br><span class="line">  &#125; head;</span><br><span class="line">  ALIGN align;</span><br><span class="line">&#125; <span class="type">header_t</span>;</span><br></pre></td></tr></table></figure><blockquote><p>其实这里可以化简, 不需要指向下一个以及上一个被分配的空间的指针</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 16 位对齐</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> align_to = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ALIGN[align_to];</span><br><span class="line"><span class="comment">// 标头</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">header</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">  &#125; head;</span><br><span class="line">  ALIGN align;</span><br><span class="line">&#125; <span class="type">header_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/.io//MemoryMalloc.png" alt="MemoryMalloc"></p><h2 id="关于内存对齐问题"><a href="#关于内存对齐问题" class="headerlink" title="关于内存对齐问题"></a>关于内存对齐问题</h2><p>我们调用sbrk分配空间的时候, 为了提高Cpu读取的效率, 我们需要进行内存对齐</p><p>例如 我们的Cpu每次读取16个字节<br>如果 分配的内存是16的n倍, 那么只需要读取n次即可<br>但是如果不是, 那么就会读取超过n次</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">假设XXXX为其他数据, OOOO为我们分配的数据</span><br><span class="line">分配同样大小的空间</span><br><span class="line"></span><br><span class="line">Cpu 读取  -&gt; XXXX XXXX XXXX XXXX </span><br><span class="line">Cpu 读取  -&gt; OOOO OOOO OOOO OOOO</span><br><span class="line">Cpu 读取  -&gt; XXXX XXXX XXXX XXXX</span><br><span class="line">如上排列, Cpu只需要读1次, 就可以获取我们分配的空间</span><br><span class="line"></span><br><span class="line">Cpu 读取  -&gt; XXXX XXXX XXXX OOOO  </span><br><span class="line">Cpu 读取  -&gt; OOOO OOOO OOOO XXXX</span><br><span class="line">Cpu 读取  -&gt; XXXX XXXX XXXX XXXX</span><br><span class="line">这样排列, Cpu就需要读2次</span><br></pre></td></tr></table></figure><blockquote><p>这就是内存对齐的好处</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果要分配size个字节, 那么实际要分配total_size个字节</span></span><br><span class="line"><span class="type">size_t</span> total_size = (<span class="built_in">sizeof</span>(<span class="type">header_t</span>) + size + align_to - <span class="number">1</span>) &amp; ~(align_to - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>其实就是使得每次分配的内存空间(包含头以及填充), 使得为16的整数倍</p><h2 id="malloc核心代码"><a href="#malloc核心代码" class="headerlink" title="malloc核心代码"></a>malloc核心代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// malloc memory space</span></span><br><span class="line"><span class="type">void</span> *now_addr = <span class="built_in">sbrk</span>(total_size);</span><br><span class="line">  <span class="comment">// failed</span></span><br><span class="line"><span class="keyword">if</span> (now_addr == (<span class="type">void</span> *)<span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s errno: %s\n&quot;</span>, __func__, <span class="built_in">strerror</span>(errno));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="free核心代码"><a href="#free核心代码" class="headerlink" title="free核心代码"></a>free核心代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free memory space</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">sbrk</span>(<span class="number">0</span> - (<span class="built_in">sizeof</span>(<span class="type">header_t</span>) + node-&gt;head.size)) == (<span class="type">void</span> *)<span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s errno: %s\n&quot;</span>, __func__, <span class="built_in">strerror</span>(ENOMEM));</span><br><span class="line">  <span class="built_in">pthrad_mutex_unlock</span>(&amp;list_locker);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调用Cmake连接指定的GLIBC</title>
      <link href="/2022/01/26/GCCLinkNewGlibc/"/>
      <url>/2022/01/26/GCCLinkNewGlibc/</url>
      
        <content type="html"><![CDATA[<h1 id="如何使用CMAKE或者GCC连接指定的GLIBC运行程序"><a href="#如何使用CMAKE或者GCC连接指定的GLIBC运行程序" class="headerlink" title="如何使用CMAKE或者GCC连接指定的GLIBC运行程序"></a>如何使用CMAKE或者GCC连接指定的GLIBC运行程序</h1><h2 id="安装新的GLIBC-2-34"><a href="#安装新的GLIBC-2-34" class="headerlink" title="安装新的GLIBC 2.34"></a>安装新的GLIBC 2.34</h2><p><code>wget</code> 下载源码包</p><blockquote><p>wget <a href="https://ftp.gnu.org/gnu/glibc/glibc-2.34.tar.gz">https://ftp.gnu.org/gnu/glibc/glibc-2.34.tar.gz</a></p></blockquote><p><code>tar</code> 解压压缩包</p><blockquote><p>tar xzfv glibc-2.34.tar.gz</p></blockquote><p><code>configure</code> 设置一下安装路径</p><blockquote><p>.&#x2F;configure –prefix&#x3D;&#x2F;opt&#x2F;glibc-2.34</p></blockquote><p><code>--prefix=</code> 你要存放的路径(建议不要覆盖自带的GLIBC)</p><span id="more"></span><blockquote><p>make -j4</p></blockquote><p><code>-j</code> 你需要开启的线程数目(用来<strong>加快编译速度</strong>)</p><blockquote><p>sudo make install</p></blockquote><p><code>sudo</code> 因为我是安装到&#x2F;opt目录下, 所以需要<code>sudo</code></p><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>转自 <a href="https://stackoverflow.com/questions/9705660/check-glibc-version-for-a-particular-gcc-compiler">https://stackoverflow.com/questions/9705660/check-glibc-version-for-a-particular-gcc-compiler</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  __GLIBC__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gnu/libc-version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GLIBC__</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;GNU libc compile-time version: %u.%u\n&quot;</span>, __GLIBC__,  __GLIBC_MINOR__);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;GNU libc runtime version:      %s\n&quot;</span>, <span class="built_in">gnu_get_libc_version</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Not the GNU C Library&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单运行一遍</p><p><img src="/.io//GCCLinkNewGlibc-1.png" alt="GCCLinkNewGlibc-1"></p><blockquote><p>我系统自带的是GLIBC3.31</p></blockquote><h2 id="GCC编译命令"><a href="#GCC编译命令" class="headerlink" title="GCC编译命令"></a>GCC编译命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++11 ../helloworld.cc -Wl,--rpath=/opt/glibc-2.34/lib -Wl,--dynamic-linker=/opt/glibc-2.34/lib/ld-linux-x86-64.so.2</span><br></pre></td></tr></table></figure><p><code>-Wl,--rpath=</code> 重新指定库的路径<br><code>-Wl,--dynamic-linker=</code> 指定动态连接库</p><p><img src="/.io//GCCLinkNewGlibc-2.png" alt="GCCLinkNewGlibc-2"></p><h2 id="CMAKE编译"><a href="#CMAKE编译" class="headerlink" title="CMAKE编译"></a>CMAKE编译</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(helloworld)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(./)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_compile_options</span>(<span class="string">&quot;-std=c++11&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;-Wl,--rpath=/opt/glibc-2.34/lib -Wl,--dynamic-linker=/opt/glibc-2.34/lib/ld-linux-x86-64.so.2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(hello helloworld.cc)</span><br></pre></td></tr></table></figure><p>主要的是<code>add_compile_options</code>中关于<code>CXXFLAGS</code>,其实这个跟GCC一样</p><p><img src="/.io//GCCLinkNewGlibc-3.png" alt="GCCLinkNewGlibc-3"></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>调用<code>rpath</code>以及<code>dynamic-linker</code>可以指定<code>GLIBC</code></p>]]></content>
      
      
      <categories>
          
          <category> C++相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RGB_AND_YUV</title>
      <link href="/2022/01/09/RGB-AND-YUV/"/>
      <url>/2022/01/09/RGB-AND-YUV/</url>
      
        <content type="html"><![CDATA[<h1 id="色彩模型"><a href="#色彩模型" class="headerlink" title="色彩模型"></a>色彩模型</h1><h2 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h2><p>通过对R, G, B三个颜色通道的变化, 并把他们相互叠加, 显示多种色彩.</p><h3 id="RGB颜色标准"><a href="#RGB颜色标准" class="headerlink" title="RGB颜色标准"></a>RGB颜色标准</h3><p><code>R</code>: red, <code>G</code>: green, <code>B</code>: blue.</p><blockquote><p>此三基色可以根据占比不同组建其他颜色.</p></blockquote><h3 id="RGB格式标准"><a href="#RGB格式标准" class="headerlink" title="RGB格式标准"></a>RGB格式标准</h3><p><strong>RGB后面的位数表示1个像素所使用的位数.</strong></p><p>RGB1, RGB4, RGB8, RGB16, RGB24, RGB32, ARGB32.</p><span id="more"></span><blockquote><p>RGB 1位可以表示2色. RGB 4位可以表示16色, RGB 8位可以表示256色, 位数越多, 显示的颜色越丰富. 24位以上即表示真彩色.</p></blockquote><blockquote><p>RGB 24位与32位是一样的, 三个分量都是占8位, 多余的位弃用, 而ARGB 32中, 多余的8位用来标记Alpha通道.</p></blockquote><h2 id="YUV"><a href="#YUV" class="headerlink" title="YUV"></a>YUV</h2><p>由于人眼对亮度的分辨率的敏感度高于色彩的分辨率的敏感度, 把亮度与色度进行分离, 增强亮度, 减少色度, 进而压缩空间.</p><h3 id="YUV颜色标准"><a href="#YUV颜色标准" class="headerlink" title="YUV颜色标准"></a>YUV颜色标准</h3><p>Y: 亮度, U和V: 色度.  </p><p>亮度一般是值0-255的黑白色, 而色度表示像素的颜色.  </p><blockquote><p>简单的说, 只有Y就是一组黑白照片, 而U和V是一组色块分布图, 两者一组合就成为了彩色照片.</p></blockquote><h3 id="YUV格式标准"><a href="#YUV格式标准" class="headerlink" title="YUV格式标准"></a>YUV格式标准</h3><p>YUV的格式标准有很多, 三者的采样比例, 主要有4:4:4, 4:2:2, 4:1:1, 4:2:0.</p><blockquote><p>可以理解成, 在一个矩形点阵上, 每一个点可以由最多Y,U,V三个分量组成, 进行行扫描与列扫描.</p></blockquote><p><code>4:4:4</code>: YUV三信道的抽样率一样.</p><blockquote><p>每个点都是有Y, U, V组成.</p></blockquote><p><code>4:2:2</code>: 在水平抽样中亮度与色度比例为 2:1, 垂直抽样率 1:1</p><blockquote><p>每行的每个点以2:1的比例, 分别由Y组成以及Y, U, V组成.</p></blockquote><p><code>4:1:1</code>: 在水平抽样中亮度与色度比例为 4:1, 垂直抽样率 1:1</p><blockquote><p>每行的每个点以4:1的比例, 分别由Y组成以及Y, U, V组成.</p></blockquote><p><code>4:2:0</code>: 在水平抽样中亮度与色度比例是 2:1, 垂直抽样是 2:1</p><blockquote><p>每行的每个点以2:1的比例, 分别由Y组成以及 Y, U或者Y, V 组成.<br>每列上由Y, U或者Y, V 组成的点为1:1.</p></blockquote><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>因为亮度与色度分离, 可以兼容古老的黑白电视.</p><h2 id="RGB与YUV之间的转换"><a href="#RGB与YUV之间的转换" class="headerlink" title="RGB与YUV之间的转换"></a>RGB与YUV之间的转换</h2><p>BT601 (标清)</p><blockquote><p>数字RGB 转 数字YUV</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Y = (<span class="number">0.257</span> * R) + (<span class="number">0.504</span> * G) + (<span class="number">0.098</span> * B) + <span class="number">16</span></span><br><span class="line">U = -( <span class="number">0.148</span> * R) - (<span class="number">0.291</span> * G) + (<span class="number">0.439</span> * B) + <span class="number">128</span></span><br><span class="line">V = (<span class="number">0.439</span> * R) - (<span class="number">0.368</span> * G) - (<span class="number">0.071</span> * B) + <span class="number">128</span></span><br></pre></td></tr></table></figure><blockquote><p>数字YUV 转 数字RGB</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B = <span class="number">1.164</span>(Y - <span class="number">16</span>) + <span class="number">2.018</span>(U - <span class="number">128</span>)</span><br><span class="line">G = <span class="number">1.164</span>(Y - <span class="number">16</span>) - <span class="number">0.813</span>(V - <span class="number">128</span>) - <span class="number">0.391</span>(U - <span class="number">128</span>)</span><br><span class="line">R = <span class="number">1.164</span>(Y - <span class="number">16</span>) + <span class="number">1.596</span>(V - <span class="number">128</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 音视频基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
